import{_ as s,c as i,o as a,a2 as l}from"./chunks/framework.Bx6qu0xe.js";const g=JSON.parse('{"title":"HTML","description":"","frontmatter":{},"headers":[],"relativePath":"basic/html.md","filePath":"basic/html.md","lastUpdated":1710401923000}'),n={name:"basic/html.md"},t=l(`<h1 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-label="Permalink to &quot;HTML&quot;">​</a></h1><h2 id="行内元素" tabindex="-1">行内元素 <a class="header-anchor" href="#行内元素" aria-label="Permalink to &quot;行内元素&quot;">​</a></h2><ul><li>行内元素只占据它对应标签的边框所包含的空间。</li><li>常见的行内元素有：<code>a</code>、<code>b</code>、<code>span</code>、<code>img</code>、<code>strong</code>、<code>sub</code>、<code>sup</code>、<code>button</code>、<code>input</code>、<code>label</code>、<code>select</code>、<code>textarea</code>。</li></ul><h2 id="块级元素" tabindex="-1">块级元素 <a class="header-anchor" href="#块级元素" aria-label="Permalink to &quot;块级元素&quot;">​</a></h2><ul><li>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</li><li>常见的块级元素有：<code>div</code>、<code>ul</code>、<code>ol</code>、<code>li</code>、<code>dl</code>、<code>dt</code>、<code>dd</code>、<code>h1</code>、<code>h2</code>、<code>h3</code>、<code>h4</code>、<code>h5</code>、<code>h6</code>、<code>p</code>。</li></ul><h2 id="行内元素与块级元素的区别" tabindex="-1">行内元素与块级元素的区别 <a class="header-anchor" href="#行内元素与块级元素的区别" aria-label="Permalink to &quot;行内元素与块级元素的区别&quot;">​</a></h2><ul><li><p>格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p></li><li><p>内容上，默认情况下，行内元素只能包含文本和其他行内元素，块级元素可以包含行内元素和其他块级元素。</p></li><li><p>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 <code>width</code> 和 <code>height</code> 无效（可以设置 <code>line-height</code>），设置 <code>margin</code> 和 <code>padding</code> 的上下不会对其他元素产生影响。</p></li></ul><h2 id="对浏览器的理解" tabindex="-1">对浏览器的理解 <a class="header-anchor" href="#对浏览器的理解" aria-label="Permalink to &quot;对浏览器的理解&quot;">​</a></h2><ul><li><p>浏览器的主要功能是将用户选择的 Web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p></li><li><p>HTML 和 CSS 规范中规定了浏览器解释 HTML 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 Web 标准的组织。</p></li><li><p>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 Web 开发者带来了严重的兼容性问题。</p></li><li><p>简单来说浏览器可以分为两部分，<strong>shell（外壳）</strong> 和 <strong>内核</strong>。其中 shell 的种类相对比较多，内核则比较少。</p></li><li><p>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等，它是调用内核来实现各种功能的。</p></li><li><p>内核才是浏览器的核心，是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核，自从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p></li></ul><h2 id="对浏览器内核的理解" tabindex="-1">对浏览器内核的理解 <a class="header-anchor" href="#对浏览器内核的理解" aria-label="Permalink to &quot;对浏览器内核的理解&quot;">​</a></h2><ul><li><p>浏览器内核主要分成两部分：<strong>渲染引擎</strong>和 <strong>JS 引擎</strong>。</p></li><li><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、XML 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p></li><li><p>JS 引擎：解析和执行 JavaScript 来实现网页的动态效果。</p></li><li><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p></li></ul><h2 id="浏览器的渲染原理" tabindex="-1">浏览器的渲染原理 <a class="header-anchor" href="#浏览器的渲染原理" aria-label="Permalink to &quot;浏览器的渲染原理&quot;">​</a></h2><p>浏览器的渲染过程是一个复杂的流程，涉及到多个阶段，以下是主要步骤：</p><ol><li><p><strong>构建文档对象模型（DOM）和样式对象模型（CSSOM）</strong></p><ul><li>浏览器首先解析 HTML 文档，创建 DOM 树，表示文档的结构。</li><li>同时，解析 CSS 文件，生成 CSSOM 树，表示文档的样式信息。</li><li>DOM 和 CSSOM 树合并形成渲染树（Render Tree），渲染树包含了所有需要渲染的节点和其样式信息。</li></ul></li><li><p><strong>布局（Layout）</strong></p><ul><li>渲染引擎遍历渲染树，计算每个元素的几何信息，例如宽度、高度、位置等。</li><li>计算的结果称为布局或回流，这是为了确定每个元素在屏幕上的确切位置和大小。</li></ul></li><li><p><strong>绘制（Painting）</strong></p><ul><li>浏览器使用布局阶段计算得到的几何信息，在屏幕上绘制页面的每个元素。</li><li>绘制过程包括填充背景、绘制边框、渲染文本等。</li></ul></li><li><p><strong>栅格化（Rasterization）</strong></p><ul><li>绘制的内容被分解成小的图块，称为栅格或位图。</li><li>每个栅格都包含页面上相应区域的像素信息。</li></ul></li><li><p><strong>合成（Compositing）</strong></p><ul><li>浏览器将栅格化的图块按照其在渲染树中的顺序绘制到屏幕上。</li><li>如果页面有多个层叠上下的元素，浏览器可能使用硬件加速合成（GPU 加速）来提高性能。</li></ul></li><li><p><strong>重绘和回流</strong></p><ul><li>当页面的某个部分需要更新时，浏览器会进行重绘（Repaint）。</li><li>当影响到布局的属性发生变化时，浏览器需要进行回流（Reflow），即重新计算布局。</li><li>重绘比回流开销小，因为重绘只涉及样式的变化，而回流涉及到布局的变化。</li></ul></li><li><p><strong>GPU 加速（可选）</strong></p><ul><li>浏览器可能会利用硬件加速（GPU）来加快页面渲染速度，特别是在合成阶段。</li><li>GPU 加速可以通过 CSS 属性（例如<code>transform</code>、<code>opacity</code>）来触发。</li></ul></li></ol><p>浏览器的渲染过程是一个高度优化的流水线，各个阶段之间相互协作，值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容现呈到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 render 树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><h2 id="渲染过程中遇到-js-文件怎么处理" tabindex="-1">渲染过程中遇到 JS 文件怎么处理 <a class="header-anchor" href="#渲染过程中遇到-js-文件怎么处理" aria-label="Permalink to &quot;渲染过程中遇到 JS 文件怎么处理&quot;">​</a></h2><ul><li><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 树时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p></li><li><p>如果你想首屏渲染得越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。当然在当下，并不是说 <code>script</code> 标签必须放在底部，也可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p></li></ul><h2 id="async-和-defer-的作用和区别" tabindex="-1"><code>async</code> 和 <code>defer</code> 的作用和区别 <a class="header-anchor" href="#async-和-defer-的作用和区别" aria-label="Permalink to &quot;\`async\` 和 \`defer\` 的作用和区别&quot;">​</a></h2><ul><li><p><code>script</code> 标签如果没有 <code>defer</code> 或 <code>async</code> 属性，浏览器会立即加载并执行指定的 JS 文件，也就是说不等待后续载入的文档元素，读到就加载并执行。</p></li><li><p><code>defer</code> 属性表示<strong>延迟执行</strong>引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 <code>document</code> 解析完毕后再执行脚本文件，在 <code>DOMContentLoaded</code> 事件触发之前完成。多个脚本按顺序执行。</p></li><li><p><code>async</code> 属性表示<strong>异步执行</strong>引入的 JavaScript，与 <code>defer</code> 的区别在于如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个 JS 文件的执行顺序无法保证。</p></li></ul><h2 id="js-延迟加载的方式" tabindex="-1">JS 延迟加载的方式 <a class="header-anchor" href="#js-延迟加载的方式" aria-label="Permalink to &quot;JS 延迟加载的方式&quot;">​</a></h2><p>JS 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 JS 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p><ul><li><p>第一种方式是我们一般采用的是将 JS 脚本放在文档的底部，来使 JS 脚本尽可能的在最后来加载执行。</p></li><li><p>第二种方式是给 JS 脚本添加 <code>defer</code> 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p></li><li><p>第三种方式是给 JS 脚本添加 <code>async</code> 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 JS 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 <code>async</code> 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p></li><li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 JS 脚本。</p></li></ul><h2 id="重绘和回流" tabindex="-1">重绘和回流 <a class="header-anchor" href="#重绘和回流" aria-label="Permalink to &quot;重绘和回流&quot;">​</a></h2><ul><li><p>重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作称为重绘。</p><p>常见会引起重绘的属性和方法：</p><ul><li>颜色属性：<code>color</code> 文本颜色、<code>background-color</code> 背景颜色</li><li>边框属性：<code>border</code> 边框样式、宽度、颜色</li><li>文本属性：<code>font-size</code> 字体大小、<code>font-family</code> 字体、<code>font-weight</code> 字体粗细、<code>text-decoration</code> 文本装饰</li><li>显示属性：<code>display</code> 元素的显示方式（例如，从 <code>none</code> 到 <code>block</code>）</li><li>定位属性：<code>position</code>: 元素定位方式（例如，从 <code>static</code> 到 <code>relative</code> 或 <code>absolute</code>）</li><li>可见性属性：<code>visibility</code> 元素可见性</li><li>背景属性：<code>background-image</code> 背景图片</li><li>轮廓属性：<code>outline</code> 轮廓样式、宽度、颜色</li><li>文本阴影属性：<code>text-shadow</code> 文本阴影效果</li><li>Opacity 属性：<code>opacity</code> 元素透明度</li><li>变换属性：<code>transform</code> 元素变换</li><li>滤镜属性（部分浏览器支持）：<code>filter</code> 图像滤镜效果</li><li>Box Shadow 属性：<code>box-shadow</code> 元素阴影效果</li><li>Flex 属性（部分浏览器支持）</li><li>动画属性：<code>animation</code> CSS 动画属性</li><li>伪类的激活状态变化：<code>:hover</code>, <code>:active</code>, <code>:focus</code> 等伪类的变化</li><li>classList 操作类名：使用 JavaScript 中的 <code>classList</code> 对元素的类名进行操作</li></ul></li><li><p>回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>常见引起回流的属性和方法：</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ul><li>添加或者删除可见的 DOM 元素。</li><li>元素尺寸改变——边距、填充、边框、宽度和高度。</li><li>内容变化，比如用户在 <code>input</code> 框中输入文字。</li><li>浏览器窗口尺寸改变 <code>resize</code> 事件发生时。</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性。</li><li>设置 <code>style</code> 属性的值。</li><li>修改网页的默认字体时。</li></ul></li></ul><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h2 id="如何减少重绘和回流" tabindex="-1">如何减少重绘和回流 <a class="header-anchor" href="#如何减少重绘和回流" aria-label="Permalink to &quot;如何减少重绘和回流&quot;">​</a></h2><p>重绘（Repaint）和回流（Reflow）是性能开销较大的操作，在前端开发中，尽量减少它们的发生是非常重要的。以下是一些减少重绘和回流的最佳实践：</p><ol><li><p><strong>使用 Class 操作样式</strong><br> 直接操作元素的 <code>style</code> 属性会强制浏览器进行回流。相反，使用 <code>classList</code> 添加或移除类，可以一次性对多个样式进行修改，减少回流的次数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.classList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new-style&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p><strong>批量修改样式</strong><br> 避免频繁单独修改样式属性，而是将多个修改合并为一次操作，例如使用 <code>requestAnimationFrame</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推荐</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  element.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>避免强制同步布局</strong><br> 尽量避免读取布局信息。读取布局信息（例如元素的宽度、高度、偏移量等）会触发回流。如果需要读取，最好将读取的布局信息缓存起来，减少对布局的重复读取。</p></li><li><p><strong>使用文档碎片（DocumentFragment）</strong><br> 当需要在 DOM 中插入大量节点时，可以使用文档碎片创建和操作节点，然后再一次性插入到 DOM 中，这样可以减少回流的次数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不推荐</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推荐</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fragment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDocumentFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fragment.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span></code></pre></div></li><li><p><strong>使用 Flexbox 和 Grid 布局</strong><br> 使用 Flexbox 和 Grid 布局可以减少元素的重绘和回流，因为它们不会像传统布局模型那样频繁引起元素的重新排列。</p></li><li><p><strong>节流和防抖</strong><br> 在处理用户输入、滚动等事件时，可以使用节流（throttle）和防抖（debounce）的技术，减少频繁的回流和重绘操作。</p></li><li><p><strong>使用 will-change</strong><br> CSS 属性 <code>will-change</code> 可以提前告诉浏览器某个元素可能会发生什么变化，从而优化性能。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.my-element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  will-change</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: transform;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><p>减少重绘和回流的关键是尽量减少对布局信息的读取和频繁修改样式，以及合理使用现代布局技术和优化策略。</p><h2 id="domcontentloaded-事件和-load-事件的区别" tabindex="-1">DOMContentLoaded 事件和 Load 事件的区别 <a class="header-anchor" href="#domcontentloaded-事件和-load-事件的区别" aria-label="Permalink to &quot;DOMContentLoaded 事件和 Load 事件的区别&quot;">​</a></h2><p><code>DOMContentLoaded</code> 事件和 <code>load</code> 事件是与页面加载过程相关的两个不同的事件，它们在触发时机和内容上存在一些区别：</p><ol><li><p><strong>DOMContentLoaded 事件：</strong></p><ul><li><strong>触发时机：</strong> <code>DOMContentLoaded</code> 事件在 HTML 文档被完全加载和解析之后触发，即当 DOM 树构建完成，但在图片和其他资源加载完成之前。</li><li><strong>应用场景：</strong> 通常用于执行需要在 DOM 就绪后执行的 JavaScript 代码，例如操作 DOM 元素、绑定事件处理程序等。因为它在 DOM 就绪后触发，不需要等待整个页面的加载完成。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DOMContentLoaded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在此执行 DOM 就绪后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>load 事件：</strong></p><ul><li><strong>触发时机：</strong> <code>load</code> 事件在整个页面及其所有依赖资源（包括图片、样式表、脚本等）都加载完成后触发。</li><li><strong>应用场景：</strong> 适用于需要等待整个页面和所有资源加载完成后执行的操作。如果你的 JavaScript 代码依赖于页面中的所有资源，可以使用 <code>load</code> 事件。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;load&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在此执行页面和资源加载完成后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ol><p><code>DOMContentLoaded</code> 事件更早地触发，表示 DOM 结构已经构建完成，而 <code>load</code> 事件则表示整个页面及其依赖资源都已加载完成。如果只需要等待 DOM 就绪，可以使用 <code>DOMContentLoaded</code> 事件，而如果需要等待整个页面加载完成，包括资源的加载，可以使用 <code>load</code> 事件。</p><h2 id="html5-新特性" tabindex="-1">HTML5 新特性 <a class="header-anchor" href="#html5-新特性" aria-label="Permalink to &quot;HTML5 新特性&quot;">​</a></h2><ol><li><p><strong>语义元素：</strong><br> 引入了一些新的语义元素，如 <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;nav&gt;</code>，以便更清晰地定义文档结构。</p></li><li><p><strong>新的表单元素：</strong><br> 引入了新的表单元素，如 <code>&lt;input&gt;</code> 的 <code>type</code> 属性的增强，支持日期、时间、邮箱等输入类型。另外，新增了 <code>&lt;datalist&gt;</code>, <code>&lt;keygen&gt;</code>, <code>&lt;output&gt;</code> 等元素。</p></li><li><p><strong>多媒体支持：</strong><br> 新增了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素，使得在网页上嵌入音频和视频更加容易。同时，引入了 <code>audio</code> 和 <code>video</code> API，提供了 JavaScript 控制多媒体的功能。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">audio</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> controls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">source</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;audio.mp3&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;audio/mp3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Your browser does not support the audio element.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">audio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;320&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;240&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> controls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">source</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;movie.mp4&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/mp4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Your browser does not support the video tag.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>Canvas 绘图：</strong><br> 引入了 <code>&lt;canvas&gt;</code> 元素，提供了通过 JavaScript 绘制图形、图像和动画的功能。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myCanvas&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;200&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;100&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myCanvas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这里使用 Canvas API 进行绘图操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>地理定位 API：</strong><br> HTML5 提供了通过浏览器获取用户地理位置信息的功能，通过 Geolocation API 实现。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (navigator.geolocation) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  navigator.geolocation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getCurrentPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> latitude </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position.coords.latitude;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> longitude </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position.coords.longitude;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理获取到的地理位置信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 不支持地理定位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>Web 存储：</strong><br> 提供了 <code>localStorage</code> 和 <code>sessionStorage</code>，允许在客户端存储数据，而无需每次请求都将数据发送到服务器。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> storedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p><strong>WebSocket：</strong><br> 引入了 WebSocket API，实现了基于 TCP 协议的全双工通信，使得浏览器和服务器之间可以实时、高效地进行双向通信。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://example.com/socket&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onopen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 连接已打开</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 接收到消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p><strong>Web Workers：</strong><br> 允许在后台运行的 JavaScript 线程，提高页面的响应性。Web Workers 能够在不阻塞主线程的情况下执行任务。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在主线程创建 Web Worker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理从 Web Worker 返回的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p><strong>离线应用和缓存：</strong><br> 提供了 Application Cache，允许开发者将 web 应用的资源缓存到本地，使得在离线状态下也能访问应用。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> manifest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cache.manifest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ol><h2 id="html-语义化的理解" tabindex="-1">HTML 语义化的理解 <a class="header-anchor" href="#html-语义化的理解" aria-label="Permalink to &quot;HTML 语义化的理解&quot;">​</a></h2><ul><li>用正确的标签做正确的事情。</li><li>HTML 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析。</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的。</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO。</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ul><h2 id="浏览器端的存储技术" tabindex="-1">浏览器端的存储技术 <a class="header-anchor" href="#浏览器端的存储技术" aria-label="Permalink to &quot;浏览器端的存储技术&quot;">​</a></h2><p>浏览器端的常用存储技术有 Cookies、LocalStorage、SessionStorage、IndexedDB 和 Cache API 等。</p><ul><li><p>Cookies<br> 优点：</p><ul><li>简单易用，通过设置 <code>document.cookie</code> 可以在客户端存储小量数据。</li><li>支持设置过期时间，可以在指定时间后自动过期。</li><li>被所有浏览器支持。</li></ul><p>缺点：</p><ul><li>存储量较小，每个 Cookie 的存储限制在 4 KB 左右。</li><li>每次同源的 HTTP 请求都会携带所有的 Cookies，增加网络流量。</li><li>受同源策略限制，只能访问设置它的域下的 Cookie。</li><li>不安全，容易被篡改，故不适合存储敏感信息。</li></ul></li><li><p>LocalStorage<br> 优点：</p><ul><li>存储容量较大，通常支持 5MB 左右。</li><li>数据在浏览器关闭后仍然保留。</li><li>简单易用，通过 <code>localStorage.setItem</code> 和 <code>localStorage.getItem</code> 进行读写。</li></ul><p>缺点：</p><ul><li>受同源策略限制，只能访问设置它的域下的数据。</li><li>无法设置过期时间，除非手动清除。</li></ul></li><li><p>SessionStorage<br> 优点：</p><ul><li>数据仅在当前会话有效，关闭标签页或浏览器后数据被清除。</li><li>同 LocalStorage 一样，支持 5MB 左右的存储。</li></ul><p>缺点：</p><ul><li>也受同源策略限制。</li><li>无法设置过期时间。</li></ul></li><li><p>IndexedDB<br> 优点：</p><ul><li>支持异步操作，适用于大量数据的存储和检索。</li><li>提供事务机制，保证数据的一致性。</li><li>存储容量较大，通常支持几百 MB 至几 GB。</li></ul><p>缺点：</p><ul><li>复杂度较高，学习和使用难度较大。</li><li>异步操作可能使得编写和维护代码更为繁琐。</li></ul></li><li><p>Cache API 优点：</p><ul><li>提供了更为灵活的缓存机制，可以缓存网络请求和资源。</li><li>支持 Service Worker，使得在离线状态下依然可以访问缓存的内容。</li></ul><p>缺点：</p><ul><li>部分浏览器可能不完全支持。</li></ul></li><li><p><strong>Cookies</strong> 适用于小量、不敏感的数据，但存在存储容量小、每次请求携带等问题。</p></li><li><p><strong>Web Storage</strong> 适用于相对较大的数据，但不支持设置过期时间。</p></li><li><p><strong>IndexedDB</strong> 适用于需要大量异步操作和较大存储容量的场景，但复杂度高。</p></li><li><p><strong>Cache API</strong> 适用于灵活的缓存机制，对于需要离线访问的应用较为有利。</p></li></ul><h2 id="浏览器内多个标签页之间的通信" tabindex="-1">浏览器内多个标签页之间的通信 <a class="header-anchor" href="#浏览器内多个标签页之间的通信" aria-label="Permalink to &quot;浏览器内多个标签页之间的通信&quot;">​</a></h2><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</p><ol><li><p>使用 <code>localStorage</code> 或 <code>sessionStorage</code><br> 这两个 Web Storage 技术可以在同一域下的不同标签页之间共享数据。当一个标签页修改 <code>localStorage</code> 或 <code>sessionStorage</code> 中的数据时，其他标签页可以通过监听 <code>storage</code> 事件来得知数据的变化。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 1 中设置数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 2 中监听 storage 事件，当页面 1 修改数据时会触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storage&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> updatedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.newValue;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理更新后的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p>使用 Broadcast Channel API<br><code>BroadcastChannel</code> API 提供了一种在不同窗口或标签页之间进行广播通信的方式。不同窗口可以通过同一个 <code>BroadcastChannel</code> 实例进行通信。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 1 中创建广播通道</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> channel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BroadcastChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my_channel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 2 中监听消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理接收到的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 1 中发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li><li><p>使用 SharedWorker<br><code>SharedWorker</code> 是一种在不同标签页之间共享状态的方式，不同于普通的 Web Worker，<code>SharedWorker</code> 可以被多个窗口共享。通过 <code>postMessage</code> 方法在不同标签页之间发送消息。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 1 中创建 SharedWorker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 2 中监听消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receivedData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理接收到的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在页面 1 中发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li><li><p>使用 WebSocket<br><code>WebSocket</code> 协议可以实现服务器推送，服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p></li></ol><h2 id="canvas-和-svg-有什么区别" tabindex="-1">Canvas 和 SVG 有什么区别 <a class="header-anchor" href="#canvas-和-svg-有什么区别" aria-label="Permalink to &quot;Canvas 和 SVG 有什么区别&quot;">​</a></h2><ul><li><p>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</p></li><li><p>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，当 SVG 图形缩放时并不会失真。</p></li></ul><h2 id="渐进增强和优雅降级" tabindex="-1">渐进增强和优雅降级 <a class="header-anchor" href="#渐进增强和优雅降级" aria-label="Permalink to &quot;渐进增强和优雅降级&quot;">​</a></h2><ul><li><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p></li><li><p>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</p></li></ul><h2 id="浏览器地址栏输入-url-到页面渲染的整个流程" tabindex="-1">浏览器地址栏输入 URL 到页面渲染的整个流程 <a class="header-anchor" href="#浏览器地址栏输入-url-到页面渲染的整个流程" aria-label="Permalink to &quot;浏览器地址栏输入 URL 到页面渲染的整个流程&quot;">​</a></h2><ol><li><p><strong>URL 解析</strong><br> 当用户在浏览器地址栏中输入 URL 时，浏览器会首先对该 URL 进行解析。URL 包括协议（如 HTTP、HTTPS）、域名、端口号、路径等组成部分。</p></li><li><p><strong>DNS 查询</strong><br> 浏览器通过 DNS（Domain Name System）解析器查询该域名对应的 IP 地址。如果 DNS 缓存中存在该域名对应的 IP 地址，则直接返回；否则，将请求发送到 DNS 服务器进行解析。</p></li><li><p><strong>建立 TCP 连接</strong><br> 浏览器使用 HTTP 协议建立与服务器的 TCP 连接（三次握手）。在建立连接的过程中，还可能进行 TLS/SSL 握手（如果是 HTTPS 协议，四次握手）来确保通信安全。</p></li><li><p><strong>发起 HTTP 请求</strong><br> 浏览器向服务器发送 HTTP 请求。该请求包括请求方法（如 GET、POST）、请求头、请求体等信息。请求头中包含了浏览器的相关信息、Accept-Encoding（指定浏览器支持的压缩算法）、Accept-Language（指定浏览器的语言偏好）等。</p></li><li><p><strong>服务器处理请求</strong><br> 服务器接收到 HTTP 请求后，根据请求的 URL 和方法进行相应的处理。处理过程可能包括查询数据库、生成动态内容、读取静态文件等操作。</p></li><li><p><strong>服务器响应</strong><br> 服务器处理完请求后，将相应的结果以 HTTP 响应的形式返回给浏览器。HTTP 响应包括状态码、响应头、响应体等部分。状态码指示了请求的处理结果，如 200 表示成功、404 表示资源未找到、500 表示服务器内部错误等。</p></li><li><p><strong>接收响应</strong><br> 浏览器接收到服务器的响应后，开始解析响应。首先，检查响应头中的 Content-Type，确定响应的数据类型（如 HTML、JSON、图片等）。然后根据相应的数据类型进行相应的处理。</p></li><li><p><strong>页面渲染</strong><br> 如果响应的是 HTML 类型的数据，浏览器开始解析 HTML，并构建 DOM 树。在构建 DOM 树的过程中，遇到外部资源（如 CSS、JavaScript、图片等）的引用，则会发起额外的请求获取这些资源。同时，浏览器还会解析 CSS，构建 CSSOM 树，并将 DOM 树和 CSSOM 树合并成渲染树。最后，浏览器根据渲染树进行页面渲染，呈现给用户。</p></li><li><p><strong>页面交互</strong><br> 页面渲染完成后，用户可以与页面进行交互。浏览器监听用户的鼠标点击、键盘输入等事件，并执行相应的 JavaScript 代码来处理这些事件，实现页面的交互效果。</p></li></ol><h2 id="前端性能优化" tabindex="-1">前端性能优化 <a class="header-anchor" href="#前端性能优化" aria-label="Permalink to &quot;前端性能优化&quot;">​</a></h2><p>前端性能优化是提高网页加载速度和用户体验的关键。以下是一些常见的前端性能优化方案：</p><ol><li><p><strong>文件优化</strong></p><ul><li><strong>合并和压缩文件：</strong> 将多个文件合并为一个，减少文件数量和大小。压缩 CSS、JavaScript 和图片等资源。减少 HTTP 请求数，避免过多的请求造成等待的情况。</li><li><strong>使用 CDN：</strong> 利用内容分发网络（CDN）加速静态资源的加载，使其从距离用户更近的服务器获取。</li></ul></li><li><p><strong>异步加载</strong></p><ul><li><strong>异步加载脚本：</strong> 使用 <code>async</code> 或 <code>defer</code> 属性，或者通过动态创建 <code>script</code> 标签，使脚本在不阻塞页面渲染的情况下加载。</li><li><strong>异步加载资源：</strong> 对于非关键资源，使用 <code>async</code>、<code>defer</code> 或者动态加载，避免阻塞渲染。</li></ul></li><li><p><strong>图片优化</strong></p><ul><li><strong>选择适当的图片格式：</strong> 使用 WebP、PNG 等现代格式。</li><li><strong>压缩图片：</strong> 对图片进行有效压缩图片，降低图片大小。</li><li><strong>懒加载图片：</strong> 只有在图片进入可视区域时加载，节省带宽和资源。</li><li><strong>使用 CSS Sprites：</strong> 将多个小图标合并为一个雪碧图，减少 HTTP 请求次数。</li><li><strong>base64：</strong> 小图片转换成 base64 编码存储。</li></ul></li><li><p><strong>缓存优化</strong></p><ul><li><strong>浏览器缓存：</strong> 使用适当的缓存头（Cache-Control、Expires、ETag 等）来控制浏览器缓存，对常用不变的资源进行缓存。</li><li><strong>本地缓存：</strong> 使用 Web Storage（LocalStorage、SessionStorage）或 IndexedDB 缓存数据，减少不必要的网络请求。</li></ul></li><li><p><strong>DNS 优化</strong></p><ul><li><strong>DNS 预解析：</strong> 使用 <code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code> 标签，提前解析域名，减少 DNS 查找时间。</li><li><strong>DNS 缓存：</strong> 通过 DNS 缓存等机制来减少 DNS 的查询次数。</li></ul></li><li><p><strong>渲染优化</strong></p><ul><li><strong>减少 DOM 操作：</strong> 减少不必要的 DOM 操作，优化 DOM 树结构。</li><li><strong>CSS、JavaScript 最小化：</strong> 移除不需要的样式和脚本，减小文件大小。</li><li><strong>使用请求动画帧（requestAnimationFrame）：</strong> 通过浏览器的优化渲染机制执行动画，提高性能。</li></ul></li><li><p><strong>服务端优化</strong></p><ul><li><strong>服务端使用 SSR：</strong> 利用服务端渲染提前生成 HTML，减轻客户端渲染的负担。</li><li><strong>服务端预渲染：</strong> 预渲染关键页面，生成静态 HTML，提高首屏加载速度。</li><li><strong>响应资源压缩：</strong> 接口响应启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</li></ul></li><li><p><strong>代码拆分（Code Splitting）</strong></p><ul><li>将代码按照模块进行拆分，按需加载，减小初始加载体积。</li></ul></li><li><p><strong>HTTP/2 和 HTTP/3</strong></p><ul><li>使用现代的 HTTP 协议，减少网络请求的开销，提高加载速度。</li></ul></li><li><p><strong>优化动画</strong></p></li></ol><ul><li>使用 CSS3 动画或者使用 GPU 加速的 transform 属性执行动画，提高性能。</li><li>避免使用会导致回流的属性，优化动画流畅性。</li></ul><ol start="11"><li><p><strong>Webpack 和其他构建工具</strong></p><ul><li>使用 Webpack 或其他构建工具进行代码压缩、文件合并、打包、Tree Shaking 等优化。</li></ul></li><li><p><strong>性能监控和分析</strong></p><ul><li>使用性能监控工具（如 Google Lighthouse、WebPageTest 等）对网站进行性能分析，及时发现和解决性能问题。</li></ul></li><li><p><strong>使用 Web Workers</strong></p><ul><li>将一些计算密集型或耗时较长的任务放入 Web Workers 中，避免阻塞主线程。</li></ul></li><li><p><strong>服务端优化：</strong></p><ul><li>使用适当的服务器，配置合理的缓存策略，使用内容分发网络（CDN）等。</li></ul></li><li><p><strong>使用 HTTPS</strong></p><ul><li>使用加密连接，保障数据传输的安全性，并能够享受 HTTP/2 和 HTTP/3 的性能优势。</li></ul></li></ol><p>这些优化方案是综合应用的结果，不同的项目和场景可能需要不同的优化策略。综合使用这些方案，可以显著提高网站的加载速度和用户体验。</p>`,55),e=[t];function p(h,k,o,d,r,E){return a(),i("div",null,e)}const y=s(n,[["render",p]]);export{g as __pageData,y as default};
