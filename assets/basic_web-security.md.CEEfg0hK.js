import{_ as o,c as i,o as t,a2 as e}from"./chunks/framework.Bx6qu0xe.js";const u=JSON.parse('{"title":"Web 安全","description":"","frontmatter":{},"headers":[],"relativePath":"basic/web-security.md","filePath":"basic/web-security.md","lastUpdated":1710402794000}'),l={name:"basic/web-security.md"},r=e('<h1 id="web-安全" tabindex="-1">Web 安全 <a class="header-anchor" href="#web-安全" aria-label="Permalink to &quot;Web 安全&quot;">​</a></h1><h2 id="xss-攻击" tabindex="-1">XSS 攻击 <a class="header-anchor" href="#xss-攻击" aria-label="Permalink to &quot;XSS 攻击&quot;">​</a></h2><p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全漏洞，它允许攻击者将恶意代码注入到网页中，以攻击用户的浏览器。XSS 攻击通常利用了 Web 应用程序未正确验证用户输入并在网页中输出的漏洞，使得攻击者能够向网页中插入恶意脚本，当用户访问包含恶意脚本的页面时，浏览器会执行这些恶意脚本，从而导致安全问题。</p><p>XSS 攻击可以分为三种类型：</p><ol><li><p><strong>存储型 XSS</strong>（Stored XSS）<br> 存储型 XSS 攻击是将恶意脚本存储到服务器上的数据库中，当用户访问包含这些恶意脚本的页面时，服务器会将存储的恶意脚本动态地插入到页面中，并执行。常见的存储型 XSS 攻击包括在论坛、留言板、博客等网站中发布包含恶意脚本的留言或评论。</p></li><li><p><strong>反射型 XSS</strong>（Reflected XSS）<br> 反射型 XSS 攻击是将恶意脚本作为参数附加到 URL 中，然后诱使用户点击包含恶意脚本的 URL，当用户点击链接时，服务器会将恶意脚本反射到页面中，并执行。反射型 XSS 攻击通常利用了网站的搜索功能或其他带有参数的页面。</p></li><li><p><strong>DOM 型 XSS</strong>（DOM-based XSS）<br> DOM 型 XSS 攻击是在客户端进行的一种攻击，恶意脚本通过修改页面的 DOM 结构来实现攻击，而不是通过服务器端的响应。攻击者通常会构造特定的 URL，当用户点击这些 URL 时，恶意脚本会被执行。与存储型 XSS 和反射型 XSS 不同，DOM 型 XSS 攻击的恶意脚本不会被发送到服务器。</p></li></ol><p>XSS 攻击可能导致以下危害：</p><ul><li>窃取用户的敏感信息，如 Cookie、Session ID、用户密码等。</li><li>控制用户的浏览器，实现恶意操作，如发起恶意请求、修改页面内容等。</li><li>篡改网页内容，传播虚假信息或广告。</li></ul><p>为了防止 XSS 攻击，可以采取以下措施：</p><ul><li><strong>输入过滤和转义</strong>：对用户输入进行严格的过滤和转义，以防止恶意脚本注入。</li><li><strong>使用 Content Security Policy（CSP）</strong>：CSP 是一种 HTTP 头部，用于指定允许加载页面的内容来源，可以防止执行外部脚本和内联脚本。</li><li><strong>使用 HttpOnly 标志设置 Cookie</strong>：将 Cookie 标记为 HttpOnly，防止 JavaScript 脚本访问敏感的 Cookie 数据。</li><li><strong>遵循安全开发指南</strong>：在开发过程中严格遵循安全开发指南，确保代码中不存在 XSS 漏洞。</li></ul><h2 id="csp" tabindex="-1">CSP <a class="header-anchor" href="#csp" aria-label="Permalink to &quot;CSP&quot;">​</a></h2><p>CSP（Content Security Policy，内容安全策略）是一种通过 HTTP 头部来控制网页浏览器加载内容的策略机制。它的主要目的是减少和报告网站的 XSS、数据注入等安全漏洞。通过 CSP，网站管理员可以告诉浏览器哪些资源可以被信任以及如何处理不受信任的资源，从而有效地保护用户不受恶意代码的攻击。</p><p>CSP 的工作原理如下：</p><ol><li><p><strong>制定策略</strong><br> 网站管理员可以在网站的 HTTP 头部中设置 CSP 策略，通过 <code>Content-Security-Policy</code> HTTP 头部来指定哪些资源允许加载，以及如何处理不受信任的资源。</p></li><li><p><strong>浏览器执行策略</strong><br> 当用户访问该网站时，浏览器会解析网站返回的 HTTP 响应头部中的 CSP 策略，并根据策略来执行加载资源的限制。</p></li></ol><p>CSP 策略通常包括以下几个方面的控制：</p><ul><li><strong>资源来源限制</strong>：指定允许加载的资源来源，可以是同源、特定域名、HTTPS、本地文件等。</li><li><strong>禁止内联脚本</strong>：禁止网页中内联的 JavaScript 代码（即 <code>&lt;script&gt;</code> 标签内的代码），只允许外部脚本。</li><li><strong>禁止内联样式</strong>：禁止网页中内联的样式代码（即 <code>&lt;style&gt;</code> 标签内的代码），只允许外部样式表。</li><li><strong>禁止 eval 和 Function</strong>：禁止使用 <code>eval()</code> 函数和 <code>new Function()</code> 构造函数动态执行代码。</li><li><strong>禁止使用特定的插件</strong>：禁止使用特定的浏览器插件，如 Flash、Java 等。</li></ul><p>通过这些限制，CSP 可以有效地防止 XSS 攻击、数据注入等安全漏洞。同时，CSP 还提供了报告机制，可以将违规的请求发送到指定的报告端点，从而帮助网站管理员识别和修复安全问题。</p><h2 id="csrf-攻击" tabindex="-1">CSRF 攻击 <a class="header-anchor" href="#csrf-攻击" aria-label="Permalink to &quot;CSRF 攻击&quot;">​</a></h2><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络安全攻击，攻击者利用用户已经登录的身份在用户不知情的情况下执行非法的操作。CSRF 攻击利用了网站对用户提交的请求没有进行有效验证的漏洞，通过在第三方网站上植入恶意代码或链接，诱使用户在已经登录了目标网站的情况下访问恶意网站，从而触发恶意请求。</p><p>CSRF 攻击的过程如下：</p><ol><li><p><strong>用户登录目标网站</strong>：用户在目标网站上进行登录，并且保持了登录状态，使得浏览器保存了用户的身份认证信息（如 Cookie）。</p></li><li><p><strong>攻击者构造恶意请求</strong>：攻击者在第三方网站上构造了一个包含恶意请求的链接或表单，该请求会执行目标网站上的敏感操作，例如修改用户的密码、转账等。</p></li><li><p><strong>用户访问恶意链接</strong>：用户在已经登录目标网站的情况下，访问了包含恶意请求的链接或表单。</p></li><li><p><strong>浏览器自动发送请求</strong>：浏览器自动携带了用户在目标网站的身份认证信息（如 Cookie），发送了恶意请求到目标网站。</p></li><li><p><strong>目标网站执行恶意请求</strong>：目标网站收到了恶意请求，并且由于请求携带了有效的用户身份认证信息，因此认为该请求是合法的，并执行了其中的恶意操作。</p></li></ol><p>通过 CSRF 攻击，攻击者可以在用户不知情的情况下执行各种恶意操作，例如修改用户账户信息、发送恶意邮件、转账等。</p><p>为了防止 CSRF 攻击，可以采取以下措施：</p><ul><li><strong>CSRF Token</strong>：在每个请求中包含一个随机生成的 CSRF Token，并在服务器端进行验证，确保请求是合法的。</li><li><strong>SameSite Cookie</strong>：将 Cookie 设置为 SameSite 属性，限制跨域请求中 Cookie 的发送，防止 CSRF 攻击利用用户的身份认证信息。</li><li><strong>双重身份验证</strong>：要求用户在敏感操作之前进行双重身份验证，例如短信验证码、邮箱验证码等，增加攻击者的难度。</li><li><strong>限制请求的权限</strong>：对于敏感操作，要求用户在进行之前进行额外的确认，例如输入密码、PIN 码等。</li></ul><h2 id="samesite-cookie" tabindex="-1">Samesite Cookie <a class="header-anchor" href="#samesite-cookie" aria-label="Permalink to &quot;Samesite Cookie&quot;">​</a></h2><p>SameSite Cookie 是用于增强浏览器安全性的一种 Cookie 属性，用于限制跨站点请求中 Cookie 的发送，从而防止 CSRF（跨站请求伪造）攻击和某些类型的跨站点信息泄露。</p><p>SameSite Cookie 的属性有三个可能的值：</p><ol><li><p><strong>Strict</strong>：Strict 模式下的 SameSite Cookie 不会随着跨站点请求发送，即只有在同一站点的请求中才会发送这些 Cookie。这样可以确保 Cookie 不会在跨站点情况下被发送，从而防止 CSRF 攻击。</p></li><li><p><strong>Lax</strong>：Lax 模式下的 SameSite Cookie 会随着导航请求（例如点击链接跳转）发送，但不会随着 POST 请求（例如表单提交、Ajax 请求）发送。这样可以在一定程度上减少 CSRF 攻击的风险，但仍允许某些导航请求携带 Cookie，以维持用户的会话状态。</p></li><li><p><strong>None</strong>：None 模式下的 SameSite Cookie 将在所有跨站点请求中发送，包括导航请求和 POST 请求。这种模式通常用于允许第三方域名下的资源访问 Cookie，例如跨站点的单点登录或集成第三方服务。</p></li></ol><h2 id="点击劫持" tabindex="-1">点击劫持 <a class="header-anchor" href="#点击劫持" aria-label="Permalink to &quot;点击劫持&quot;">​</a></h2><p>点击劫持是一种利用透明的、覆盖在合法网页上的恶意页面的技术，使用户在不知情的情况下点击了隐藏的恶意按钮或链接，从而触发了恶意操作。点击劫持通常通过将恶意网页覆盖在合法网页之上，并使用户误以为点击的是合法网页上的内容来实现。攻击者利用了合法网页上的透明元素或 iframe 元素来实现点击劫持，从而欺骗用户执行恶意操作。</p><p>点击劫持的工作原理如下：</p><ol><li><p><strong>构造恶意页面</strong>：攻击者创建一个恶意网页，并将其覆盖在目标网页之上。恶意页面中包含一个或多个透明的按钮或链接，用于触发恶意操作。</p></li><li><p><strong>欺骗用户点击</strong>：攻击者诱使用户访问包含恶意页面的网站，并误以为点击的是正常页面上的内容。由于恶意页面覆盖在正常页面之上，并且透明度较低，用户无法察觉到恶意页面的存在。</p></li><li><p><strong>触发恶意操作</strong>：用户在不知情的情况下点击了恶意页面上的按钮或链接，从而触发了恶意操作。这可能包括转账、发布恶意信息、点击广告等操作。</p></li></ol><p>点击劫持可能导致以下危害：</p><ul><li>窃取用户的个人信息，如账号、密码等。</li><li>控制用户的浏览器，实施恶意操作，例如点击广告、转账等。</li><li>传播恶意软件，使用户的设备感染病毒或恶意软件。</li></ul><p>为了防止点击劫持攻击，可以采取以下措施：</p><ul><li><strong>X-Frame-Options 头部</strong>：在 HTTP 响应中添加 X-Frame-Options 头部，禁止网页被嵌入到 iframe 中，从而防止点击劫持攻击。</li><li><strong>Framebusting 脚本</strong>：在网页中添加 Framebusting 脚本，检测网页是否被嵌入到 iframe 中，如果是则跳出 iframe。</li><li><strong>Content Security Policy（CSP）</strong>：通过 CSP 策略限制网页的加载内容，防止恶意网页覆盖在正常网页之上。</li><li><strong>用户教育和意识提高</strong>：提高用户对点击劫持的认识，教育用户在浏览网页时注意地址栏和页面的可信度，避免点击可疑链接和按钮。</li></ul><h2 id="sql-注入攻击" tabindex="-1">SQL 注入攻击 <a class="header-anchor" href="#sql-注入攻击" aria-label="Permalink to &quot;SQL 注入攻击&quot;">​</a></h2><p>SQL 注入是一种常见的网络安全攻击方式，攻击者通过向应用程序的输入字段注入恶意的 SQL 代码，从而使得应用程序执行非预期的 SQL 查询或操作，导致数据泄露、数据篡改、服务器瘫痪等安全问题。SQL 注入攻击利用了应用程序对用户输入的不合理处理或过滤，从而让攻击者能够执行任意的 SQL 查询或命令。</p><p>SQL 注入攻击的工作原理如下：</p><ol><li><p><strong>构造恶意输入</strong>：攻击者在应用程序的输入字段（如表单、URL 参数、Cookie 等）中注入恶意的 SQL 代码，通常是通过输入框输入恶意的 SQL 语句或在 URL 参数中添加恶意的 SQL 代码。</p></li><li><p><strong>执行恶意查询</strong>：当应用程序接收到带有恶意 SQL 代码的输入后，会将其拼接到 SQL 查询语句中，并执行该查询语句，而不会对输入进行充分验证或过滤。</p></li><li><p><strong>执行恶意操作</strong>：恶意 SQL 查询被执行后，攻击者可以获取、篡改或删除数据库中的数据，甚至控制整个数据库服务器，从而对应用程序造成严重的安全威胁。</p></li></ol><p>SQL 注入攻击可能导致以下危害：</p><ul><li>窃取敏感信息：攻击者可以通过注入恶意 SQL 查询来窃取用户的账号、密码、个人信息等敏感数据。</li><li>数据篡改：攻击者可以通过注入恶意 SQL 代码来修改数据库中的数据，例如更改用户权限、删除数据等。</li><li>服务器瘫痪：攻击者可以通过注入恶意 SQL 代码来执行耗费大量资源的查询，从而导致服务器瘫痪或拒绝服务。</li></ul><p>为了防止 SQL 注入攻击，可以采取以下措施：</p><ul><li><p><strong>使用参数化查询（Prepared Statements）</strong>：使用参数化查询可以防止 SQL 注入攻击，参数化查询可以将用户输入的数据与 SQL 查询语句分开，使得输入的数据不会被解释为 SQL 代码，从而防止注入攻击。</p></li><li><p><strong>输入验证和过滤</strong>：对用户输入的数据进行严格的验证和过滤，只允许合法的数据输入到 SQL 查询中，拒绝包含特殊字符或 SQL 关键字的输入。</p></li><li><p><strong>最小权限原则</strong>：为数据库用户分配最小权限，限制其对数据库的操作范围，避免过高的权限被滥用。</p></li><li><p><strong>使用 ORM 框架</strong>：使用 ORM（Object-Relational Mapping）框架可以将对象和数据库之间的映射关系抽象出来，避免直接拼接 SQL 查询语句，从而减少 SQL 注入攻击的风险。</p></li></ul>',43),s=[r];function n(S,a,p,g,c,C){return t(),i("div",null,s)}const h=o(l,[["render",n]]);export{u as __pageData,h as default};
