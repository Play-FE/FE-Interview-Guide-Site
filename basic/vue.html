<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 前端面试指南</title>
    <meta name="description" content="前端工程师的面试复习指南">
    <meta name="generator" content="VitePress v1.0.0-rc.45">
    <link rel="preload stylesheet" href="/assets/style.C_mLCv64.css" as="style">
    
    <script type="module" src="/assets/app.DfiPh1fg.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.Bx6qu0xe.js">
    <link rel="modulepreload" href="/assets/chunks/theme.C4HNBpKu.js">
    <link rel="modulepreload" href="/assets/basic_vue.md.CJcMmngY.lean.js">
    <link rel="icon" href="/images/logo.png">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c3508ec8></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c3508ec8> Skip to content </a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar has-sidebar" data-v-f1e365da data-v-b9c8b02d><div class="wrapper" data-v-b9c8b02d><div class="container" data-v-b9c8b02d><div class="title" data-v-b9c8b02d><div class="VPNavBarTitle has-sidebar" data-v-b9c8b02d data-v-28a961f9><a class="title" href="/" data-v-28a961f9><!--[--><!--]--><!--[--><img class="VPImage logo" src="/images/logo.png" alt data-v-35a7d0b8><!--]--><span data-v-28a961f9>前端面试指南</span><!--[--><!--]--></a></div></div><div class="content" data-v-b9c8b02d><div class="content-body" data-v-b9c8b02d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-b9c8b02d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-b9c8b02d data-v-492ea56d><span id="main-nav-aria-label" class="visually-hidden" data-v-492ea56d>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/basic/html.html" tabindex="0" data-v-492ea56d data-v-2781b5e7><!--[--><span data-v-2781b5e7>基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/advance/webpack.html" tabindex="0" data-v-492ea56d data-v-2781b5e7><!--[--><span data-v-2781b5e7>进阶</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/network/http.html" tabindex="0" data-v-492ea56d data-v-2781b5e7><!--[--><span data-v-2781b5e7>网络协议</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/algorithm/data-structures.html" tabindex="0" data-v-492ea56d data-v-2781b5e7><!--[--><span data-v-2781b5e7>算法</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-b9c8b02d data-v-ead91a81><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-ead91a81 data-v-b79b56d4 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-b79b56d4></span><span class="vpi-moon moon" data-v-b79b56d4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-b9c8b02d data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Play-FE/front-end-interview-guide" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-717b8b75><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-b9c8b02d data-v-9b536d0b data-v-e5380155><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-e5380155><span class="vpi-more-horizontal icon" data-v-e5380155></span></button><div class="menu" data-v-e5380155><div class="VPMenu" data-v-e5380155 data-v-97491713><!----><!--[--><!--[--><!----><div class="group" data-v-9b536d0b><div class="item appearance" data-v-9b536d0b><p class="label" data-v-9b536d0b>Appearance</p><div class="appearance-action" data-v-9b536d0b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-9b536d0b data-v-b79b56d4 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-b79b56d4></span><span class="vpi-moon moon" data-v-b79b56d4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-9b536d0b><div class="item social-links" data-v-9b536d0b><div class="VPSocialLinks social-links-list" data-v-9b536d0b data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Play-FE/front-end-interview-guide" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-717b8b75><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-b9c8b02d data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-b9c8b02d><div class="divider-line" data-v-b9c8b02d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-c9ba27ad><button data-v-c9ba27ad>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-ec846e01><div class="curtain" data-v-ec846e01></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-ec846e01><span class="visually-hidden" id="sidebar-aria-label" data-v-ec846e01> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-ec846e01><section class="VPSidebarItem level-0 has-active" data-v-ec846e01 data-v-f24171a4><!----><div class="items" data-v-f24171a4><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/html.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>HTML</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/css.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>CSS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/javascript.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>JavaScript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/typescript.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>TypeScript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/vue.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>Vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/angular.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>Angular</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/react.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>React</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/web-security.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>Web 安全</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f24171a4 data-v-f24171a4><div class="item" data-v-f24171a4><div class="indicator" data-v-f24171a4></div><a class="VPLink link link" href="/basic/miniprogram.html" data-v-f24171a4><!--[--><p class="text" data-v-f24171a4>小程序</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-6d7b3c46 data-v-c14bfc45><div class="content" data-v-c14bfc45><div class="outline-marker" data-v-c14bfc45></div><div class="outline-title" role="heading" aria-level="2" data-v-c14bfc45>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-c14bfc45><span class="visually-hidden" id="doc-outline-aria-label" data-v-c14bfc45> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-c14bfc45 data-v-3f927ebe><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _basic_vue" data-v-83890dd9><div><h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="mvc、mvp-和-mvvm-模式" tabindex="-1">MVC、MVP 和 MVVM 模式 <a class="header-anchor" href="#mvc、mvp-和-mvvm-模式" aria-label="Permalink to &quot;MVC、MVP 和 MVVM 模式&quot;">​</a></h2><p>在前端开发中，MVC（Model-View-Controller）、MVP（Model-View-Presenter）和 MVVM（Model-View-ViewModel）是常见的架构模式，用于组织和管理应用程序的代码。它们都旨在实现将应用程序的不同部分分离开来，以提高代码的可维护性、可测试性和可扩展性。</p><ul><li><p><strong>MVC（Model-View-Controller）</strong></p><ul><li><strong>模型（Model）</strong>：负责应用程序的数据结构、逻辑和数据库交互等。</li><li><strong>视图（View）</strong>：负责应用程序的用户界面呈现，通常由 HTML 和 CSS 组成。</li><li><strong>控制器（Controller）</strong>：充当模型和视图之间的中介，处理用户输入并更新模型和视图。在 Web 应用中，通常是处理路由和 HTTP 请求的部分。</li></ul><p>MVC 模式的核心思想是将应用程序分为三个不同的组件，每个组件有其专注的责任。这样的分离使得代码更易于管理和维护。</p></li><li><p><strong>MVP（Model-View-Presenter）</strong></p><ul><li><strong>模型（Model）</strong>：同 MVC 中的模型，负责应用程序的数据。</li><li><strong>视图（View）</strong>：同 MVC 中的视图，负责用户界面呈现。</li><li><strong>主持人（Presenter）</strong>：取代了 MVC 中的控制器，负责处理用户输入、更新模型并在必要时更新视图。Presenter 的作用是解耦视图和模型，使其更容易进行单元测试。</li></ul><p>MVP 模式在 MVC 的基础上进一步强调了视图和模型之间的分离，并引入了 Presenter 作为中介，使得视图更加 passively 与模型交互。</p></li><li><p><strong>MVVM（Model-View-ViewModel）</strong></p><ul><li><strong>模型（Model）</strong>：同 MVC 和 MVP 中的模型，负责应用程序的数据。</li><li><strong>视图（View）</strong>：同 MVC 和 MVP 中的视图，负责用户界面呈现。</li><li><strong>视图模型（ViewModel）</strong>：MVVM 中最为核心的部分。视图模型是视图的抽象，负责从模型中获取数据并准备视图所需的数据。视图模型通常是纯粹的 JavaScript 对象，它实现了视图和模型之间的数据绑定。</li></ul><p>MVVM 模式相比 MVC 和 MVP 更进一步，它引入了视图模型的概念，通过数据绑定实现了视图和模型之间的双向绑定。这样，当模型发生变化时，视图会自动更新，反之亦然。</p></li></ul><h2 id="观察者模式和发布订阅模式" tabindex="-1">观察者模式和发布订阅模式 <a class="header-anchor" href="#观察者模式和发布订阅模式" aria-label="Permalink to &quot;观察者模式和发布订阅模式&quot;">​</a></h2><ul><li><p>发布订阅模式其实属于广义上的观察者模式。</p></li><li><p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p></li><li><p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p></li></ul><h2 id="vue-双向数据绑定原理" tabindex="-1">Vue 双向数据绑定原理 <a class="header-anchor" href="#vue-双向数据绑定原理" aria-label="Permalink to &quot;Vue 双向数据绑定原理&quot;">​</a></h2><p>Vue.js 中的双向数据绑定是其最显著的特性之一，它允许视图层（HTML）和数据模型之间的自动同步。这意味着当数据模型发生变化时，视图会自动更新，并且当用户在视图中输入内容时，数据模型也会相应地更新。</p><p>实现双向数据绑定的原理如下：</p><ul><li><p><strong>数据劫持（Data Observation）</strong>： Vue.js 使用了一个名为“响应式系统（Reactivity System）”的机制来实现数据劫持。当你创建一个 Vue 实例时，Vue 会遍历数据对象的所有属性，使用 <code>Object.defineProperty()</code> 方法将它们转换为 getter 和 setter。通过这种方式，当属性被访问或修改时，Vue 能够捕获到，并执行相应的操作。</p><p>在 Vue.js 2 中 使用 <code>Object.defineProperty()</code> 来进行数据劫持，有一些对属性的操作无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，Vue.js 2 内部通过重写函数解决了这个问题。</p><p>在 Vue.js 3 中，数据劫持的实现方式与 Vue.js 2 有所不同，主要通过 Proxy 对象来实现。</p><ul><li><p><strong>Proxy 对象</strong><br> 在 Vue.js 3 中，使用了 ES6 中的 Proxy 对象来替代 <code>Object.defineProperty()</code>。Proxy 对象允许你创建一个代理，用于定义基本操作的自定义行为（例如属性查找、赋值等）。通过 Proxy 对象，Vue.js 能够劫持数据对象的操作，并在数据发生变化时进行相应的处理。</p></li><li><p><strong>Reflect API</strong><br> 为了与 Proxy 对象配合使用，Vue.js 3 还使用了 Reflect API。Reflect API 提供了一组用于操作对象的方法，例如 <code>Reflect.get()</code>、<code>Reflect.set()</code> 等。Vue.js 3 在数据劫持时使用 Reflect API 来执行实际的操作，而不是直接在目标对象上操作，这样可以更加灵活地处理各种情况。</p></li><li><p><strong>优势</strong></p><ul><li>Proxy 对象更加强大和灵活，可以监听更多类型的操作，例如数组的变化。</li><li>Proxy 对象可以监听整个对象的变化，而不仅仅是属性的变化。</li><li>Proxy 对象的性能通常比 <code>Object.defineProperty()</code> 更好，特别是在大型数据对象上的性能表现更佳。</li></ul></li></ul></li><li><p><strong>虚拟 DOM（Virtual DOM）</strong>： Vue.js 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个 JavaScript 对象，它对真实 DOM 进行抽象，然后在内存中对其进行操作。当数据发生变化时，Vue.js 会生成一个新的虚拟 DOM，并与之前的虚拟 DOM 进行比较，找出变化的部分，然后只更新变化的部分到真实 DOM 中，而不是重新渲染整个页面。</p></li><li><p><strong>事件监听（Event Listening）</strong>： Vue.js 会在模板编译时，为每个模板中的指令（例如 <code>v-model</code>）或事件绑定（例如 <code>@input</code>）创建对应的监听器。当用户输入内容时，Vue.js 会通过这些监听器捕获到事件，并更新数据模型。</p></li><li><p><strong>数据绑定（Data Binding）</strong>： 在 Vue.js 中，你可以使用 <code>v-model</code> 指令来实现双向数据绑定。<code>v-model</code> 指令在表单元素上创建双向数据绑定，将表单元素的值绑定到数据模型上，并且当表单元素的值发生变化时，数据模型也会更新。</p></li></ul><p>综上所述，Vue.js 的双向数据绑定是通过<strong>数据劫持</strong>、<strong>虚拟 DOM</strong>、<strong>事件监听</strong>和<strong>数据绑定</strong>等机制来实现的。这些机制使得数据模型与视图之间的同步变得简单高效，极大地提高了开发效率。</p><h2 id="虚拟-dom-virtual-dom" tabindex="-1">虚拟 DOM（Virtual DOM） <a class="header-anchor" href="#虚拟-dom-virtual-dom" aria-label="Permalink to &quot;虚拟 DOM（Virtual DOM）&quot;">​</a></h2><p>虚拟 DOM 是一个 JavaScript 对象，它是对真实 DOM 的抽象。通过使用虚拟 DOM，Vue.js 能够在内存中维护一颗以 JavaScript 对象为节点的树，这颗树与真实 DOM 对应着页面的结构。</p><p>当数据发生变化时，Vue.js 首先会生成一个新的虚拟 DOM 树，然后通过 diff 算法比较新的虚拟 DOM 树与旧的虚拟 DOM 树的差异。通过比较，Vue.js 找出需要更新的部分，并只更新这些部分到真实 DOM 上，而不是重新渲染整个页面。这样可以大大提高页面的渲染性能和响应速度。</p><p><strong>优势</strong>：</p><ul><li><strong>提高性能</strong>：由于操作虚拟 DOM 可以避免直接操作真实 DOM，减少了浏览器的重绘和回流，从而提高了页面的渲染性能。</li><li><strong>简化操作</strong>：通过使用虚拟 DOM，开发者可以像操作普通 JavaScript 对象一样操作 DOM，简化了操作复杂 DOM 结构的过程。</li><li><strong>跨平台兼容性</strong>：虚拟 DOM 不依赖于具体的浏览器平台，因此可以在不同的平台上运行，提高了跨平台兼容性。</li></ul><h2 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;diff 算法&quot;">​</a></h2><p>在 Vue.js 中，diff 算法是用于比较虚拟 DOM 树的变化，并最小化 DOM 操作的一种算法。这种算法可以高效地找出虚拟 DOM 树中变化的部分，并只更新这些部分到真实 DOM，而不是重新渲染整个页面。</p><ul><li><p><strong>概念</strong><br> diff 算法是一种通过比较两棵树的差异，找出最小的变更，并应用到真实 DOM 上的技术。在 Vue.js 中，这两棵树分别是当前虚拟 DOM 树和更新后的虚拟 DOM 树。</p></li><li><p><strong>算法流程</strong></p><ul><li><strong>深度优先遍历</strong>：Vue.js 使用<strong>深度优先遍历</strong>算法来逐层比较虚拟 DOM 树的节点。</li><li><strong>同级比较</strong>：在遍历过程中，Vue.js 会比较同级节点之间的差异，判断节点是否需要更新、新增或删除。</li><li><strong>唯一 key</strong>：在比较过程中，Vue.js 会使用节点的唯一 key 来确定节点的身份，以确保正确地识别出节点的变化。</li><li><strong>更新策略</strong>：根据节点的变化类型（新增、删除、移动、更新等），Vue.js 会采取不同的更新策略，最大程度地减少 DOM 操作的次数。</li><li><strong>递归处理</strong>：如果节点发生变化，则递归处理其子节点，直到完成整个树的比较。</li></ul></li><li><p><strong>优化策略</strong></p><ul><li><strong>Key 的重要性</strong>：使用唯一 key 可以帮助 Vue.js 更准确地识别节点的变化，提高 diff 算法的效率。</li><li><strong>移动操作的优化</strong>：在节点移动时，Vue.js 会尽可能地复用已存在的 DOM 元素，而不是直接删除和重新创建，以减少 DOM 操作。</li><li><strong>批量处理操作</strong>：Vue.js 会将多个变更操作合并为一个批量操作，减少了对真实 DOM 的操作次数，提高了性能。</li></ul></li><li><p><strong>时间复杂度</strong><br> Vue.js 中的 diff 算法的时间复杂度为 O(n)，其中 n 表示节点的数量。这是由于 diff 算法会遍历整个虚拟 DOM 树，并比较节点之间的差异，因此其时间复杂度与节点的数量成正比。</p></li></ul><h2 id="vue-2-的生命周期" tabindex="-1">Vue 2 的生命周期 <a class="header-anchor" href="#vue-2-的生命周期" aria-label="Permalink to &quot;Vue 2 的生命周期&quot;">​</a></h2><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程，一共有 8 个阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。开发者可以在这些钩子函数中执行自定义的操作。</p><ul><li><p><strong>创建阶段（Creation）</strong></p><ul><li><strong>beforeCreate</strong>：在实例初始化之后、数据观测（data observation）和 event/watcher 事件配置之前被调用。此时组件实例还未初始化，因此无法访问到 data 和 methods 等选项。</li><li><strong>created</strong>：在实例创建完成后被立即调用。这个阶段完成了数据的观测、属性和方法的运算，但是尚未挂载到 DOM 上。</li></ul></li><li><p><strong>挂载阶段（Mounting）</strong></p><ul><li><strong>beforeMount</strong>：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li><strong>mounted</strong>：在挂载结束后被调用：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此钩子函数。此时组件已经挂载到 DOM 上，可以访问到 DOM 元素。（请求数据）</li></ul></li><li><p><strong>更新阶段（Updating）</strong></p><ul><li><strong>beforeUpdate</strong>：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中对数据进行修改，但是不会触发附加的重新渲染过程。</li><li><strong>updated</strong>：由于数据更改导致的虚拟 DOM 重新渲染和打补丁后调用。此时组件的 DOM 已经更新完毕，可以执行依赖于 DOM 的操作。</li></ul></li><li><p><strong>销毁阶段（Destruction）</strong></p><ul><li><strong>beforeDestroy</strong>：在实例销毁之前调用。在这一步，实例仍然完全可用。（清除定时器、解绑全局事件）</li><li><strong>destroyed</strong>：在实例销毁之后调用。此时组件已经从 DOM 中移除，所有的事件监听器和子实例也都被销毁。</li></ul></li><li><p><strong>错误处理阶段（Error Handling）</strong></p><ul><li><strong>errorCaptured</strong>：当捕获一个来自子孙组件的错误时被调用。可以返回 false 以阻止该错误继续向上传播。</li></ul></li></ul><p>当使用 <code>keep-alive</code> 组件的时候，还有两个钩子函数，分别是 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p><h2 id="vue-3-的生命周期" tabindex="-1">Vue 3 的生命周期 <a class="header-anchor" href="#vue-3-的生命周期" aria-label="Permalink to &quot;Vue 3 的生命周期&quot;">​</a></h2><p>Vue 3 的生命周期与 Vue 2 相比有了一些变化。在 Vue 3 中，生命周期钩子被分为两类：</p><ul><li><strong>选项式 API 生命周期钩子</strong>：这些钩子与 Vue 2 中的生命周期钩子相同，但它们是作为选项传递给 Vue 组件的。</li><li><strong>组合式 API 生命周期钩子</strong>：这些钩子是新的，它们允许你在组件的任何地方使用它们。</li></ul><h3 id="选项式-api-生命周期钩子" tabindex="-1">选项式 API 生命周期钩子 <a class="header-anchor" href="#选项式-api-生命周期钩子" aria-label="Permalink to &quot;选项式 API 生命周期钩子&quot;">​</a></h3><ul><li><strong>beforeCreate</strong>：在组件实例被创建之前被调用。</li><li><strong>created</strong>：在组件实例被创建之后被调用。</li><li><strong>beforeMount</strong>：在组件实例被挂载到 DOM 之前被调用。</li><li><strong>mounted</strong>：在组件实例被挂载到 DOM 之后被调用。</li><li><strong>beforeUpdate</strong>：在组件实例更新之前被调用。</li><li><strong>updated</strong>：在组件实例更新之后被调用。</li><li><strong>beforeDestroy</strong>：在组件实例被销毁之前被调用。</li><li><strong>destroyed</strong>：在组件实例被销毁之后被调用。</li></ul><h3 id="组合式-api-生命周期钩子" tabindex="-1">组合式 API 生命周期钩子 <a class="header-anchor" href="#组合式-api-生命周期钩子" aria-label="Permalink to &quot;组合式 API 生命周期钩子&quot;">​</a></h3><ul><li><strong>onBeforeMount</strong>：与 <code>beforeMount</code> 钩子相同。</li><li><strong>onMounted</strong>：与 <code>mounted</code> 钩子相同。</li><li><strong>onBeforeUpdate</strong>：与 <code>beforeUpdate</code> 钩子相同。</li><li><strong>onUpdated</strong>：与 <code>updated</code> 钩子相同。</li><li><strong>onBeforeUnmount</strong>：与 <code>beforeDestroy</code> 钩子相同。</li><li><strong>onUnmounted</strong>：与 <code>destroyed</code> 钩子相同。</li><li><strong>onErrorCaptured</strong>：在组件中捕获到错误时被调用。</li><li><strong>onRenderTracked</strong>：在组件的渲染被追踪时被调用。</li></ul><h2 id="生命周期钩子的使用" tabindex="-1">生命周期钩子的使用 <a class="header-anchor" href="#生命周期钩子的使用" aria-label="Permalink to &quot;生命周期钩子的使用&quot;">​</a></h2><p>以下是一些使用生命周期钩子的示例：</p><ul><li>在 <code>beforeCreate</code> 钩子中初始化数据</li><li>在 <code>mounted</code> 钩子中订阅数据变化</li><li>在 <code>beforeUpdate</code> 钩子中执行 DOM 操作</li><li>在 <code>updated</code> 钩子中进行网络请求</li><li>在 <code>onErrorCaptured</code> 钩子中处理错误</li></ul><h2 id="keep-alive-组件" tabindex="-1">keep-alive 组件 <a class="header-anchor" href="#keep-alive-组件" aria-label="Permalink to &quot;keep-alive 组件&quot;">​</a></h2><p><code>&lt;keep-alive&gt;</code> 是 Vue.js 中的一个内置组件，用于保留组件状态或避免重新渲染。它可以将动态组件包裹起来，并缓存不活动的组件实例，而不会销毁它们。当组件再次被访问时，不需要重新创建，而是直接从缓存中取出并重新渲染，从而提高了性能和用户体验。</p><p>下面是 <code>&lt;keep-alive&gt;</code> 组件的主要特性和用法：</p><ul><li><p><strong>特性</strong></p><ul><li><strong>包裹动态组件</strong>：<code>&lt;keep-alive&gt;</code> 主要用于包裹动态组件，可以是通过 <code>&lt;component&gt;</code> 标签动态渲染的组件，也可以是通过路由动态加载的组件。</li><li><strong>缓存不活动组件</strong>：一旦组件被包裹在 <code>&lt;keep-alive&gt;</code> 内部，当组件不活动时（例如被切换到其他页面），它将被缓存起来而不是被销毁，从而保留其状态。</li><li><strong>激活钩子</strong>：<code>&lt;keep-alive&gt;</code> 组件提供了两个钩子函数 <code>activated</code> 和 <code>deactivated</code>，用于在组件被激活和停用时进行操作。</li></ul></li><li><p><strong>用法</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;currentComponent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在上面的示例中，<code>&lt;component&gt;</code> 标签渲染的组件将被 <code>&lt;keep-alive&gt;</code> 组件包裹起来，从而实现了组件的缓存。<code>currentComponent</code> 是一个动态绑定的组件名称或组件对象，根据实际需求动态切换不同的组件。</p></li><li><p><strong>钩子函数</strong></p><ul><li><strong>activated</strong>：在组件被激活时调用，即组件被插入到 DOM 中并进行显示。</li><li><strong>deactivated</strong>：在组件被停用时调用，即组件被从 DOM 中移除并隐藏起来。</li></ul></li></ul><p>使用 <code>&lt;keep-alive&gt;</code> 组件可以有效地提高页面性能，特别是在大型单页应用中，当页面切换频繁时能够减少不必要的组件销毁和重新创建，从而加快页面加载速度和提升用户体验。</p><h2 id="vue-组件通信" tabindex="-1">Vue 组件通信 <a class="header-anchor" href="#vue-组件通信" aria-label="Permalink to &quot;Vue 组件通信&quot;">​</a></h2><ul><li><p><strong>Props / Emit（父子组件通信）</strong></p><ul><li><strong>Props</strong>：父组件通过 props 向子组件传递数据。子组件通过 props 接收数据，并根据传递的数据进行渲染。</li><li><strong>Emit</strong>：子组件通过 $emit 方法触发事件，将需要传递给父组件的数据作为参数传递给父组件。父组件通过监听子组件的事件，从而获取子组件传递的数据。</li></ul></li><li><p><strong>Provide / Inject（祖先组件向后代组件传递数据）</strong></p><ul><li><strong>Provide</strong>：祖先组件通过 provide 选项向后代组件提供数据。提供的数据可以是基本数据类型或对象，后代组件通过 inject 选项接收提供的数据。</li><li><strong>Inject</strong>：后代组件通过 inject 选项接收来自祖先组件提供的数据。</li></ul></li><li><p><strong>$parent / $children</strong></p><ul><li>$parent 属性可以让子组件访问其父组件。</li><li>$children 属性可以让父组件访问其所有子组件。</li></ul></li><li><p><strong>$attrs / $listeners（透传属性和事件）</strong></p><ul><li><strong>$attrs</strong>：父组件通过 v-bind=&quot;$attrs&quot; 将属性透传给子组件，子组件可以通过 $attrs 获取父组件传递的属性。</li><li><strong>$listeners</strong>：父组件通过 v-on=&quot;$listeners&quot; 将事件透传给子组件，子组件可以通过 $listeners 获取父组件传递的事件。</li></ul></li><li><p><strong>Ref / Refs</strong></p><ul><li><strong>Ref</strong>：父组件通过 ref 属性获取子组件的引用，从而调用子组件中的方法或访问子组件的属性。</li><li><strong>Refs</strong>：在 Vue 3 中，可以通过 ref 函数创建一个响应式的引用，并通过 ref 绑定到子组件中，从而实现对子组件的访问和操作。</li></ul></li><li><p><strong>Event Bus（事件总线）</strong></p><ul><li>创建一个全局的 Vue 实例作为事件总线，在组件中通过该实例进行事件的发布和订阅，实现组件之间的通信。但是，事件总线在大型应用中会导致事件的管理和维护变得复杂，因此在小型应用中使用较为合适。</li></ul></li><li><p><strong>Vuex / Pinia（状态管理）</strong><br> Vuex 和 Pinia 是 Vue.js 的官方状态管理库，用来实现全局状态管理，从而实现任意组件之间的数据共享。</p></li></ul><h2 id="computed-和-watch" tabindex="-1">computed 和 watch <a class="header-anchor" href="#computed-和-watch" aria-label="Permalink to &quot;computed 和 watch&quot;">​</a></h2><p>在 Vue.js 中，<code>computed</code> 和 <code>watch</code> 是用于监听数据变化并执行相应逻辑的两种重要属性。它们都与响应式数据绑定相关，但用途和使用方式略有不同。</p><h3 id="computed-计算属性" tabindex="-1">Computed（计算属性） <a class="header-anchor" href="#computed-计算属性" aria-label="Permalink to &quot;Computed（计算属性）&quot;">​</a></h3><p><code>computed</code> 是一个 Vue 实例的属性，用于声明一个计算属性。它的值是一个函数，该函数可以返回计算后的值，Vue.js 会自动将其缓存，只有在依赖的响应式数据发生改变时才会重新计算。<code>computed</code> 主要用于派生出一个新的数据，以供模板中使用，它具有以下特点：</p><ul><li><strong>自动缓存</strong>：当依赖的响应式数据没有发生变化时，<code>computed</code> 属性会直接返回上一次的计算结果，而不会重新执行计算函数。</li><li><strong>懒计算</strong>：只有当 <code>computed</code> 属性在模板中被引用时，计算函数才会被执行，这样可以避免不必要的计算。</li><li><strong>响应式</strong>：<code>computed</code> 属性会自动跟踪依赖的响应式数据，当这些数据发生变化时，<code>computed</code> 会重新计算其值。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fullName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.firstName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.lastName;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="watch-监听器" tabindex="-1">Watch（监听器） <a class="header-anchor" href="#watch-监听器" aria-label="Permalink to &quot;Watch（监听器）&quot;">​</a></h3><p><code>watch</code> 是一个 Vue 实例的选项，用于监听一个指定的数据，并在该数据变化时执行特定的逻辑。它的值可以是一个函数或者一个对象，对象中的属性对应着需要监听的数据，值为回调函数。<code>watch</code> 主要用于监听数据的变化并执行异步或复杂的操作，它具有以下特点：</p><ul><li><strong>可监听对象和深度监听</strong>：可以监听对象和数组的变化，并通过设置 <code>deep: true</code> 进行深度监听。</li><li><strong>更灵活的操作</strong>：可以执行一些比较复杂的操作，例如异步请求、定时器等。</li><li><strong>监听特定属性</strong>：可以通过字符串形式或函数形式指定需要监听的属性。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;firstName 改变了&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;obj.prop&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;obj.prop 改变了&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="区别和适用场景" tabindex="-1">区别和适用场景 <a class="header-anchor" href="#区别和适用场景" aria-label="Permalink to &quot;区别和适用场景&quot;">​</a></h3><ul><li><strong><code>computed</code> 适用于派生出一个新的数据</strong>，通常是依赖于一个或多个响应式数据计算而来的数据，它具有自动缓存和懒计算的特性，适合用于模板中频繁使用的数据。</li><li><strong><code>watch</code> 适用于监听一个指定的数据的变化</strong>，并执行一些复杂的逻辑，例如异步操作、定时器等。适合处理一些需要特定操作的情况，比如数据变化时发起网络请求等。</li></ul><h2 id="vue-router-中的钩子函数" tabindex="-1">vue-router 中的钩子函数 <a class="header-anchor" href="#vue-router-中的钩子函数" aria-label="Permalink to &quot;vue-router 中的钩子函数&quot;">​</a></h2><p>Vue Router 中的钩子函数是用于在路由导航过程中执行特定逻辑的函数。它们允许您在路由发生变化前或后执行某些操作，例如验证导航、加载数据、修改页面标题等。</p><ul><li><p><strong>全局前置守卫</strong></p><ul><li><strong>beforeEach(to, from, next)</strong>：在路由跳转之前被调用，可以用于进行全局的路由导航守卫逻辑。例如，验证用户是否登录或是否有权限访问该路由。</li><li><strong>beforeResolve(to, from, next)</strong>：在路由跳转之前被调用，但在路由组件内的 <code>beforeRouteEnter</code> 守卫之前调用。用于确保所有异步路由组件都被解析。</li><li><strong>afterEach(to, from)</strong>：在路由跳转完成之后被调用，无论是跳转到相同的路由还是跳转到不同的路由。</li></ul></li><li><p><strong>路由独享守卫</strong></p><ul><li><strong>beforeEnter(to, from, next)</strong>：在路由独享守卫中定义，只在该路由生效。在路由被激活时调用，可用于对特定路由进行验证或逻辑处理。</li></ul></li><li><p><strong>组件内的守卫</strong></p><ul><li><strong>beforeRouteEnter(to, from, next)</strong>：在路由进入该组件前被调用，此时组件实例尚未创建，因此无法访问 <code>this</code>。可以通过 <code>next(vm =&gt; {})</code> 获取组件实例。</li><li><strong>beforeRouteUpdate(to, from, next)</strong>：在当前路由改变，但是该组件被复用时被调用。例如，从 <code>/user/1</code> 导航到 <code>/user/2</code> 时，同一个组件实例被复用。</li><li><strong>beforeRouteLeave(to, from, next)</strong>：在离开该路由前被调用，可以用于在离开当前页面时执行一些清理操作或提醒用户。如果确认离开，需要调用 <code>next()</code>，否则可以调用 <code>next(false)</code> 或者传递一个路由对象来重新定向。</li></ul></li></ul><h2 id="route-和-router" tabindex="-1">$route 和 $router <a class="header-anchor" href="#route-和-router" aria-label="Permalink to &quot;$route 和 $router&quot;">​</a></h2><ul><li><code>$route</code> 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</li><li><code>$router</code> 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h2 id="vue-修饰符" tabindex="-1">Vue 修饰符 <a class="header-anchor" href="#vue-修饰符" aria-label="Permalink to &quot;Vue 修饰符&quot;">​</a></h2><p>在 Vue.js 中，修饰符是用于改变指令行为或者监听器行为的特殊标记，它们可以与指令一起使用，以便更灵活地控制指令的行为。以下是常用的 Vue 修饰符及其作用：</p><ul><li><p><strong>v-on 修饰符</strong></p><ul><li><strong>.stop</strong>：阻止事件继续传播。</li><li><strong>.prevent</strong>：阻止事件的默认行为。</li><li><strong>.capture</strong>：事件捕获模式，即在捕获阶段处理事件。</li><li><strong>.self</strong>：只当事件是从触发元素自身触发时才触发回调。</li><li><strong>.once</strong>：只触发一次事件处理器，之后移除。</li><li><strong>.passive</strong>：告诉浏览器不要阻止默认事件的默认行为，用于提高滚动性能。</li></ul></li><li><p><strong>v-bind 修饰符</strong>：</p><ul><li><strong>.prop</strong>：用于绑定 DOM 属性。</li><li><strong>.camel</strong>：将 kebab-case 特性名转换为 camelCase。</li><li><strong>.sync</strong>：用于实现子组件和父组件之间双向数据绑定。</li></ul></li><li><p><strong>v-model 修饰符</strong>：</p><ul><li><strong>.lazy</strong>：在 input 事件中同步改变数据而不是在 change 事件中。</li><li><strong>.number</strong>：将输入值转为数值类型。</li><li><strong>.trim</strong>：自动过滤输入的首尾空白字符。</li></ul></li><li><p><strong>v-show 修饰符</strong>：</p><ul><li><strong>.sync</strong>：用于实现子组件和父组件之间双向数据绑定。</li></ul></li><li><p><strong>v-text 和 v-html 修饰符</strong>：</p><ul><li><strong>.once</strong>：只渲染一次，之后不再更新。</li></ul></li><li><p><strong>v-slot 修饰符</strong>：</p><ul><li><strong>#default</strong>：默认插槽。</li><li><strong>#name</strong>：具名插槽。</li></ul></li><li><p><strong>事件修饰符</strong>：</p><ul><li><strong>.stop</strong>：阻止事件继续传播。</li><li><strong>.prevent</strong>：阻止事件的默认行为。</li><li><strong>.capture</strong>：事件捕获模式。</li><li><strong>.self</strong>：只当事件是从触发元素自身触发时才触发回调。</li><li><strong>.once</strong>：只触发一次事件处理器。</li><li><strong>.passive</strong>：告诉浏览器不要阻止默认事件的默认行为。</li></ul></li></ul><h2 id="vue-中-key-值的作用" tabindex="-1">Vue 中 key 值的作用 <a class="header-anchor" href="#vue-中-key-值的作用" aria-label="Permalink to &quot;Vue 中 key 值的作用&quot;">​</a></h2><p>在 Vue.js 中，<code>key</code> 是用于帮助 Vue 识别 VDOM 中的每个节点的特殊属性。当 Vue 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认使用“就地复用”策略。如果数据项的顺序被改变，Vue 将不是移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>然而，这种默认的模式会导致一个问题：当一个数组中的某些元素的标识（即 key 值）发生改变时，Vue 不会知道哪个元素被修改了，导致页面的错误渲染。</p><p>因此，为了给 Vue 提供一个提示，以便它跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一的 key 值。这个 key 值需要是每项数据在列表中唯一的标识符，通常是数据中的某个唯一值，比如数据项的 ID。</p><p><code>key</code> 值的作用主要有以下几个方面：</p><ol><li><strong>跟踪节点身份</strong>：Vue 使用 <code>key</code> 属性来识别节点的身份，确保在数据改变时能够正确地重用和重新排序现有元素，而不会导致错误的渲染。</li><li><strong>优化性能</strong>：通过正确使用 <code>key</code> 属性，可以提高 Vue 的性能，减少不必要的 DOM 操作，尤其是在处理大型列表或频繁更新的情况下。</li><li><strong>避免重复渲染</strong>：使用 <code>key</code> 属性能够避免相同的数据项被重复渲染，确保每个节点的状态正确。</li></ol></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-87be45d1><!--[--><!--]--><div class="edit-info" data-v-87be45d1><!----><div class="last-updated" data-v-87be45d1><p class="VPLastUpdated" data-v-87be45d1 data-v-9da12f1d>Last updated: <time datetime="2024-03-14T07:25:25.000Z" data-v-9da12f1d></time></p></div></div><nav class="prev-next" data-v-87be45d1><div class="pager" data-v-87be45d1><a class="VPLink link pager-link prev" href="/basic/typescript.html" data-v-87be45d1><!--[--><span class="desc" data-v-87be45d1>Previous page</span><span class="title" data-v-87be45d1>TypeScript</span><!--]--></a></div><div class="pager" data-v-87be45d1><a class="VPLink link pager-link next" href="/basic/angular.html" data-v-87be45d1><!--[--><span class="desc" data-v-87be45d1>Next page</span><span class="title" data-v-87be45d1>Angular</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Released under the AGPL-3.0 License</p><p class="copyright" data-v-c970a860>Copyright © 2024-present XPoet</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"advance_architecture.md\":\"B_zBP3lz\",\"advance_engineering.md\":\"D7GgGX_z\",\"advance_vite.md\":\"BNeUIPGw\",\"advance_webpack.md\":\"JprG6riq\",\"algorithm_data-structures.md\":\"DEa2QQ6y\",\"advance_component-library.md\":\"BsVM3Rc3\",\"network_https.md\":\"B7FP9bJv\",\"basic_html.md\":\"NkBIZy2k\",\"basic_miniprogram.md\":\"DuQ7XJEN\",\"basic_react.md\":\"mf3weZNO\",\"basic_vue.md\":\"CJcMmngY\",\"network_http2.md\":\"BAmPFkM2\",\"index.md\":\"DcuJ4vHr\",\"basic_web-security.md\":\"CEEfg0hK\",\"basic_angular.md\":\"C4PR9a6o\",\"network_http.md\":\"3o1CY-4A\",\"basic_typescript.md\":\"CmCmLtW_\",\"advance_nodejs.md\":\"T7_jyhqc\",\"basic_css.md\":\"Xq2BjbHe\",\"basic_javascript.md\":\"C9r5kwMs\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"前端面试指南\",\"description\":\"前端工程师的面试复习指南\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/images/logo.png\",\"outline\":{\"level\":[2,2]},\"nav\":[{\"text\":\"基础\",\"link\":\"/basic/html\"},{\"text\":\"进阶\",\"link\":\"/advance/webpack\"},{\"text\":\"网络协议\",\"link\":\"/network/http\"},{\"text\":\"算法\",\"link\":\"/algorithm/data-structures\"}],\"sidebar\":{\"basic\":[{\"items\":[{\"text\":\"HTML\",\"link\":\"/basic/html\"},{\"text\":\"CSS\",\"link\":\"/basic/css\"},{\"text\":\"JavaScript\",\"link\":\"/basic/javascript\"},{\"text\":\"TypeScript\",\"link\":\"/basic/typescript\"},{\"text\":\"Vue\",\"link\":\"/basic/vue\"},{\"text\":\"Angular\",\"link\":\"/basic/angular\"},{\"text\":\"React\",\"link\":\"/basic/react\"},{\"text\":\"Web 安全\",\"link\":\"/basic/web-security\"},{\"text\":\"小程序\",\"link\":\"/basic/miniprogram\"}]}],\"advance\":[{\"items\":[{\"text\":\"Webpack\",\"link\":\"/advance/webpack\"},{\"text\":\"Vite\",\"link\":\"/advance/vite\"},{\"text\":\"工程化\",\"link\":\"/advance/engineering\"},{\"text\":\"组件库\",\"link\":\"/advance/component-library\"},{\"text\":\"Node.js\",\"link\":\"/advance/nodejs\"},{\"text\":\"手写 JS\",\"link\":\"/advance/nodejs\"},{\"text\":\"架构设计\",\"link\":\"/advance/architecture\"}]}],\"network\":[{\"items\":[{\"text\":\"HTTP\",\"link\":\"/network/http\"}]}],\"algorithm\":[{\"items\":[{\"text\":\"数据结构\",\"link\":\"/algorithm/data-structures\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Play-FE/front-end-interview-guide\"}],\"footer\":{\"message\":\"Released under the AGPL-3.0 License\",\"copyright\":\"Copyright © 2024-present XPoet\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>